#!/usr/bin/env perl -w

use warnings;
use strict;
use Data::Dumper;

use Getopt::Long;

use R2::CheckDependencies;


#==========================================================================
# This script reads a protein multiple alignment in clustal format
# and counts the frequencies of each amino acid at each position of the
# alignment. The script can either count or ignore gaps.
#
# The output consists of two files one with the amino acid frequencies
# in decimal numbers and the other showing the fractions with integer
# numbers.
#
# Input paramaters:
#
# -i, --aln-file {path}
#    Path to the .aln file generated by ClustalX
#
# -d, --outdir {path}
#    Directory where output files will be put. If directory does
#    not exist, it will be created.
#    Default value is "./freq_counts";
#
# -a, --count-all-aa
#    Flag indicating whether counts will be reported for all 20
#    starndard amino acids.
#    This option is negated by default.
#
# -l, --aa-list {string}
#    List of one-letter amino acid codes, separated by comma, that will
#    be counted. This option is incompatible with -a.
#
# -u, --unusual-aa {string}
#    List of comma-separated unusual non-standard amino acids
#    (in one-letter code) that should also be counted (e.g. U, O, etc).
#    If this option is not given and a non-standard amino acid is found,
#    an error will be generated.
#    By default no unusual amino acis are counted
#
# -g, --count-gaps
#    Switch indicating that gaps will be counted as an amino acid.
#    Gaps can be ignored with the option --no-count-gaps.
#    Default value (count gaps).
#
#
#==========================================================================


#==========================================================================
#Check dependencies

my @dependencies = ("grep");
my $CheckDep_obj = new R2::CheckDependencies();
$CheckDep_obj -> dependencies_list(\@dependencies);
#$CheckDep_obj -> allow_no_dependencies(1);
$CheckDep_obj -> checkDependencies;



#==========================================================================
#read command line arguments


#Path to multiple alignment file
my $alnfile = undef;


#Default ouput directory where results will be placed
my $outdir = './freq_counts';


#Identify if all amino acids should be counted
my $countAll = 0;


#Custom list of amino acids that will be counted.
#Amino acids should be in one letter code separated by commas
my $aaList = "";
my $listUsualAA   = "ARNDCQEGHILKMFPSTWYV";


#List of non-standard aminoacids to be counted. So far this is
#the list I've found so far: O (Pyrrolysine), U (Selenocysteine),
#B (Aspartic acid or Asparagine), Z (Glutamic acid or Glutamine),
#X (Any amino acid), J (Leucine or Isoleucine)
my $unusualAA = "";
my $listUnusualAA = "OUBZXJ";

#Amino acids allowed in alignments
my $valid_symbols = $listUsualAA . $listUnusualAA . '-';
my $alnLength = 0;

#This is the list of amino acids that will be counted.
#Which is the union of the lists:
#   ($aaList or $listUsualAA) and $unusualAA
my @aa2count = ();


#Flag indicating whether gaps will be counted as amino acids.
#More specifically, this indicates whether a column for gaps will
#be added to the results.
my $countGaps = 0;


read_command_line_arguments();

#print Data::Dumper->Dump([$alnfile, $outdir, $aaList, $countAll, $unusualAA,
#			  $countGaps, \@aa2count],
#			 [qw(*alnfile *outdir *aaList *countAll *unusualAA 
#			     *countGaps *aa2count)]);
#exit;



#==========================================================================
#Read multiple alignment in clustal format


my %sequences = ();
parse_multiple_aln ($alnfile, \%sequences);

#print Data::Dumper->Dump([\%sequences],["*sequences"]);
#exit;



#==========================================================================
#Get the counts of amino acids per position.

get_counts (\%sequences, $outdir);





#Get the frequency of occurance of each amino acid
sub get_counts {

  my ($seqHash, $oDir) = @_;


  #the indexes to map the position of each amino acid
  #in the alingment
  my @indexes = 0 .. $alnLength - 1;



  #------------------------------------------------------------
  #Define whihc aminoacids will be counted and initialize all
  #counts to zero

  my %counts = map {$_ => {} } @aa2count;
  $counts{'others'} = {};

  #Treat the gap as an aminoacid (if requested).
  if ($countGaps) {
    $counts{'-'} = {};
  }

  #initialize all counts to zero
  foreach my $aa (keys %counts) {
    foreach my $idx (@indexes) {
      $counts{$aa}{$idx+1} = 0;
    }
  }
#  print Data::Dumper->Dump([\%counts],["*counts"]);
#  exit;


  #------------------------------------------------------------
  #Count here the amino acids per position


  #Get the aligned sequences
  my @alnSeqs = values %{ $seqHash };

  #Make the counts now
 POS:foreach my $pos (@indexes) {
  SEQ:foreach my $seq (@alnSeqs) {

      my $symbol = $seq->[$pos];

      if (exists $counts{$symbol}) {
	$counts{$symbol}{$pos + 1} += 1;
      }
      else {
	
	#If $symbol is '-', it means that user does not want
	#to count gaps, otherwise it would be part of %counts.
	unless ($symbol eq '-') {
	  $counts{'others'}{$pos + 1} += 1;
	}
      }
    }
  }
#  print Data::Dumper->Dump([\%counts],["*counts"]);
#  <STDIN>;


  #------------------------------------------------------------
  #Now generate the output files

  my $outDecFile = "$outdir/output_decimal.txt";
  my $outFraFile = "$outdir/output_fraction.txt";

  my $nSeqs = scalar @alnSeqs;

  open (my $dec, ">", $outDecFile) || die $!;
  open (my $fra, ">", $outFraFile) || die $!;

  #print headers
  my @sorted_aa = sort {$a cmp $b} @aa2count;
  if ($countGaps) {
    push (@sorted_aa, '-');
    push (@sorted_aa, 'others');
  }
  else {
    push (@sorted_aa, 'others');
  }
  print $dec "\t", join ("\t", @sorted_aa), "\n";
  print $fra "\t", join ("\t", @sorted_aa), "\n";


  foreach my $idx (@indexes) {
    my $pos = $idx + 1;
    print $fra "$pos";
    print $dec "$pos";
    foreach my $aa (@sorted_aa) {
      print $fra "\t$counts{$aa}{$pos}/$nSeqs";
      print $dec "\t", $counts{$aa}{$pos}/$nSeqs;
    }
    print $fra "\n";
    print $dec "\n";
  }
  close $fra;
  close $dec;
}







#Parse multiple alignment
sub parse_multiple_aln {

  my ($alnPath, $outHash) = @_;


  open (my $aln, "<", $alnPath) || die $!;

  while (<$aln>) {

    chomp;

    #Ignore empty lines
    next unless ($_);

    #Ignore header line
    next if (/^CLUSTAL.+multiple sequence alignment/);

    #trim spaces from the beginning and end of line
    s/^\s+//;
    s/\s+$//;
    s/[:\*\.]+//g; #Remove the conservation symbols


    my ($id, $seq) = split(/\s+/, $_);

    #there must be values for both options
    next unless ($id && $seq);

    #id can be any string, but the sequence can only contain
    #valid characters
    if ($seq =~ /^[$valid_symbols]+$/) {

      if (exists $outHash->{$id}) {
	$outHash->{$id} .= $seq;
      }
      else {
	$outHash->{$id} .= $seq;
      }
    }

  }
  close $aln;

  #There must be at least one sequence in the alignment
  #(Note: probably I should request at least 2)
  unless (%{ $outHash }) {
    die "\n\nError: No sequences found in alignment.\n\n";
  }


  #------------------------------------------------------------
  #Valudate the length of all the sequences in the alignment

  #the length of the first sequence will be used as refernce
  $alnLength = length ([values(%{ $outHash })]->[0]);


  #The sequences must be all of the same length,
  while (my ($id, $seq) = each %{ $outHash }) {

    unless ($alnLength == length $seq) {
      die "\n\nError: All sequences in the alignment must be of the same length\n\n";
    }

    #Each sequence is now an array
    $outHash->{$id} = [ split (//, $seq) ];
  }
}


#==========================================================================
#Read command line arguments

sub read_command_line_arguments {

  #if no arguments are given print the help
  if (! @ARGV) {
    print_help();
  }


  my $status = GetOptions(
      "i|aln-file=s"    => \&read_aln_file,
      "d|out-dir=s"     => \&read_outdir,
      "a|count-all"     => \$countAll,
      "l|aa-list=s"     => \&read_aa_list,
      "u|unusual-aa=s"  => \&read_unusual_aa_list,
      "g|count-gaps!"   => \$countGaps,
      "h|help"          => sub { print_help(); },
      "<>"              => sub { die "Error: Unknown argument: $_[0]\n"; }
  );
  die "\n" unless ($status);


  #Options -a and -l cannot be given at the same time
  die "\nError: option -a is incompatible with option -l\n\n" if ($countAll && $aaList);

  unless ($countAll || $aaList || $unusualAA) {
    die "\n\nError: at least one of these options must be given: -a -l -u\n\n";
  }


  #The list of aminoacids that will be counted
  if ($countAll) {
    @aa2count = split (//, $listUsualAA . $unusualAA);
  }
  else {
    @aa2count = split (//, $aaList . $unusualAA);
  }
}



#Read multiple alignment file name. File must exist
#and have a CLUSTAL header
sub read_aln_file {

  my ($option, $value) = @_;

  #Check that file exists and is not empty
  unless (-f $value && ! (-z $value)) {
    die "\nError: Could not read alignment file: $value\n";
  }

  #Check that alignment file has the Clustal header.
  #(this validation can be improved with a better regular expression)
  my $header = `grep CLUSTAL $value`;
  unless ($header) {
    die "\nError: alignment is not in clustal format (header missing)\n"
  }

  $alnfile = $value;
}



#Read the ouput dir, if directory does not exist, it will be created
sub read_outdir {

  my ($option, $value) = @_;


  #Validation could include a minimum number of amino acids.
  system "mkdir -p $value" unless (-d $value);

  $outdir = $value;
}



#Read the list of amino acids to count
sub read_aa_list {

  my ($option, $value) = @_;

  my $val = uc $value;

  $val =~ s/,//g;

  die "\nError: empty list of amino acids to count\n" unless ($val);

  #list must contain valid amino acid symbols
  unless ($val =~ /^[$listUsualAA,]+$/) {
    die "\nThere are illegal amino acid symbols in list $value\n";
  }

  $aaList = $val;

}



#Read the list of unusual amino acids to count
sub read_unusual_aa_list {

  my ($option, $value) = @_;

  my $val = uc $value;

  $val =~ s/,//g;

  die "\nError: empty list of amino acids to count\n" unless ($val);

  #list must contain valid amino acid symbols
  unless ($val =~ /^[$listUnusualAA]+$/) {
    die "\nThere are unknown non-standard amino acid symbols in list: $value\n";
  }

  $unusualAA = $val;

}



sub print_help {

  #
  # $errMsg: The error message to be diplayed
  #
  # $printHelp: boolean value indicating whether the help of the
  #             program will be displayed.
  #

  my $help = <<'HELP';

 This script reads a protein multiple alignment in clustal format
 and counts the frequencies of each amino acid at each position of the
 alignment. The script can either count or ignore gaps.

 The output consists of two files one with the amino acid frequencies
 in decimal numbers and the other showing the fractions with integer
 numbers.

 Input paramaters:

 -i, --aln-file {path}
    Path to the .aln file generated by ClustalX

 -d, --outdir {path}
    Directory where output files will be put. If directory does
    not exist, it will be created.
    Default value is "./freq_counts";

 -a, --count-all-aa
    Flag indicating whether counts will be reported for all 20
    starndard amino acids.
    This option is negated by default.

 -l, --aa-list {string}
    List of one-letter amino acid codes, separated by comma, that will
    be counted. This option is incompatible with -a.

 -u, --unusual-aa {string}
    List of comma-separated unusual non-standard amino acids
    (in one-letter code) that should also be counted (e.g. U, O, etc).
    If this option is not given and a non-standard amino acid is found,
    an error will be generated.
    By default no unusual amino acis are counted

 -g, --count-gaps
    Switch indicating that gaps will be counted as an amino acid.
    Gaps can be ignored with the option --no-count-gaps.
    Default value (count gaps).



HELP

  print $help;
  exit;
}
